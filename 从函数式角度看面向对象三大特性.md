### 前言

我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。
关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。

什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？

### 函数式概念

又称**泛函编程**，是一种[编程范型](https://zh.wikipedia.org/wiki/%E7%B7%A8%E7%A8%8B%E5%85%B8%E7%AF%84)，它将电脑运算视为[数学](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)上的[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6))计算，并且避免使用[程序状态](https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81&action=edit&redlink=1)以及[易变对象](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6)。函数编程语言最重要的基础是[λ演算](https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97)（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

比起[命令式编程](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B)，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过

函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。函数式编程为我们提供了另外一种抽象和思考的方式。函数式编程是一种风格 与编程语言无关， 面向对象也是一种风格 与编程语言无关，两种风格并不矛盾，可以结合的- 叫 functional object([Objects in OCaml](https://link.zhihu.com/?target=http%3A//caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html%23sec36))

### 函数式特性

- **函数是"第一等公民"**

  所谓["第一等公民"](http://en.wikipedia.org/wiki/First-class_function)（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

  举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。

  ```
  var print = function(i){ console.log(i);};
  [1,2,3].forEach(print);
  ```


- **闭包**

  ​

- **高阶函数**

  高阶函数就是参数为函数或返回值为函数的函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。有了高阶函数，就可以将复用的粒度降低到函数级别，相对于面向对象语言，复用的粒度更低。

  举例来说，假设有如下的三个函数，

  ```
  def sumInts(a: Int, b: Int): Int =
    if (a > b) 0 else a + sumInts(a + 1, b)

  def sumCubes(a: Int, b: Int): Int =
    if (a > b) 0 else cube(a) + sumCubes(a + 1, b)

  def sumFactorials(a: Int, b: Int): Int =
    if (a > b) 0 else fact(a) + sumFactorials(a + 1, b)
  ```

  分别是求a到b之间整数之和，求a到b之间整数的立方和，求a到b之间整数的阶乘和。

  其实这三个函数都是以下公式的特殊情况
   ``` \sum_{n=a}^{b}{f(n)} ```
  三个函数不同的只是其中的f不同，那么是否可以抽象出一个共同的模式呢？

  我们可以定义一个高阶函数sum：

  ```
  def sum(f: Int => Int, a: Int, b: Int): Int =
    if (a > b) 0
    else f(a) + sum(f, a + 1, b)
  ```

  其中参数f是一个函数，在函数中调用f函数进行计算，并进行求和。

  然后就可以写如下的函数

  ```
  def sumInts(a: Int, b: Int) = sum(id, a, b)
  def sumCubs(a: Int, b: Int) = sum(cube, a, b)
  def sumFactorials(a: Int, b: Int) = sum(fact, a, b)

  def id(x: Int): Int = x
  def cube(x: Int): Int = x * x * x
  def fact(x: Int): Int = if (x == 0) 1 else fact(x - 1)
  ```

  这样就可以重用sum函数来实现三个函数中的求和逻辑。
  （示例来源：https://d396qusza40orc.cloudfront.net/progfun/lecture_slides/week2-2.pdf）

  高阶函数提供了一种函数级别上的依赖注入（或反转控制）机制，在上面的例子里，sum函数的逻辑依赖于注入进来的函数的逻辑。很多GoF设计模式都可以用高阶函数来实现，如Visitor，Strategy，Decorator等。比如Visitor模式就可以用集合类的map()或foreach()高阶函数来替代。

  ​

- **柯里化**

  curryiny 将接受多个参数的函数变换成接受其中部分参数，并且返回接受余下参数的新函数。（维基百科中的定义是接受一个单一参数的新函数，然而现实中currying技术的涵义被延伸了。）
  比如幂函数`pow(x, y)`，它接受两个参数——x和y，计算x^y。使用currying技术，可以将y固定为2转化为只接受单一参数x的平方函数，或者将y固定为3转化为立方函数。代码如下：

  ```
  #平方函数
  def square (int x):
      return pow(x, 2)

  #立方函数
  def cube (int x):
      return pow(x, 3)
  ```

  熟悉设计模式的朋友已经感觉到，currying完成的事情就是函数（接口）封装，它将一个已有的函数（接口）做封装，得到一个新的函数（接口），这与适配器模式[（Adapter pattern）](http://en.wikipedia.org/wiki/Adapter_pattern)的思想是一致的。

- **只用"表达式"，不用"语句"**

  "表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。

  原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。

  当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。

  一切皆表达式思维：if b then 100 else 10，这不是条件跳转，而是一个三元表达式，返回100或者10，swift中有这样表达。


- **不修改状态**

  上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。
  在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。

  let a = 100，意义不是把100赋值给变量a，而是把a符号绑定(或者叫匹配)到100。

  由于变量值是不可变的，对于值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不便。例如一个Point类，其moveBy方法不是改变已有Point实例的x和y坐标值，而是返回一个新的Point实例。

  ```
  class Point(x: Int, y: Int){
      override def toString() = "Point (" + x + ", " + y + ")"
      def moveBy(deltaX: Int, deltaY: Int) = {
          new Point(x + deltaX, y + deltaY)
      }
  } 
  ```

  （示例来源：Anders Hejlsberg在echDays 2010上的演讲）

  同样由于变量不可变，纯函数编程语言无法实现循环，这是因为For循环使用可变的状态作为计数器，而While循环或DoWhile循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归。

  ​

  通常来说，算法都有递推（iterative）和递归（recursive）两种定义，以阶乘为例，阶乘的递推定义为：
  而阶乘的递归定义
  递推定义的计算时需要使用一个累积器保存每个迭代的中间计算结果，Java代码如下：

  ```
  static int fact(int n){
    int acc = 1;
    for(int k = 1; k <= n; k++){
      acc = acc * k;
    }
    return acc;
  }
  ```
  而递归定义的计算的Scala代码如下：
  def fact(n: Int):Int= {
    if(n == 0) return 1
    n * fact(n-1)
  }
  我们可以看到，没有使用循环，没有使用可变的状态，函数更短小，不需要显示地使用累积器保存中间计算结果，而是使用参数n（在栈上分配）来保存中间计算结果。
  （示例来源：1. [Recursion](https://link.zhihu.com/?target=http%3A//blogs.msdn.com/b/doriancorompt/archive/2012/01/08/1-recursion-where-are-my-for-while-loops.aspx)）

- **pipeline**

  这个技术的意思是，把函数实例成一个一个的action，然后，把一组action放到一个数组或是列表中，然后把数据传给这个action list，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。compose函数

- **惰性求值**

  执行顺序不依赖语句顺序，更易并发，

  函数式编程语言还提供惰性求值（Lazy evaluation，也称作call-by-need），是在将表达式赋值给变量（或称作绑定）时并不计算表达式的值，而在变量第一次被使用时才进行计算。这样就可以通过避免不必要的求值提升性能。在Scala里，通过lazy val来指定一个变量是惰性求值的，如下面的示例所示：
  scala> val x = { println("x"); 15 }
  x
  x: Int = 15

  scala> lazy val y = { println("y"); 13 }
  y: Int = <lazy>

  scala> y
  y
  res3: Int = 13

  scala> y
  res4: Int = 13
  （示例来源：scala - What does a lazy val do?）

  可以看到，在Scala的解释器中，当定义了x变量时就打印出了“x”，而定义变量y时并没有打印出”y“，而是在第一次引用变量y时才打印出来。

  ​

### 函数式与其它区别

- 面向对象，面向过程

  - 抽象思维方式

    函数式考虑数据的变换过程，A->B->C->D->E。 而面向对象，考虑，我应该有哪些对象，每个对象实现哪些功能。

  - 面向对象编程是也是一种命令式编程。

    命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），一句话，命令式程序就是一个冯诺依曼机的指令序列。

  **函数式编程关心数据的映射，命令式编程关心解决问题的步骤**

  函数式编程在使用的时候的特点就是，你已经再也不知道数据是从哪里来了，每一个函数都是为了用小函数组织成更大的函数，函数的参数也是函数，函数返回的也是函数，最后得到一个超级牛逼的函数，就等着别人用他来写一个main函数把数据灌进去了。

  纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。

  只要不用for、while语句，不要修改变量的值，不要用同步I/O，就可以假装是声明式编程了。

  - 没有赋值

    注意到与命令式风格不同的是没有赋值，这意味着reason 程序的时候每个变量的值是不变的 不用考虑程序变量随着时间的变化 -- 大大降低了程序的复杂性。

  - 复用粒度

    函数式的利用粒度更小，以函数为单位，而面向对象以对象为单位。

    ​


### 函数式的优点

- **引用透明**

  引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。

  有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。

- **没有"副作用"**

  所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。
  函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。

- **代码简洁，开发快速**

  函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。

- **接近自然语言，易于理解**

  函数式编程的自由度很高，可以写出很接近自然语言的代码。

  前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：

  ```
  　　subtract(multiply(add(1,2), 3), 4)
  ```
    对它进行变形，不难得到另一种写法：

  ```
  　　add(1,2).multiply(3).subtract(4)
  ```
  ​  这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：

  ```
  　　merge([1,2],[3,4]).sort().search("2")
  ```

- **易于测试，不容易出错**

  函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。

  程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）

- **易于"并发编程"**

  函数式编程不需要考虑"死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署"并发编程"（concurrency）。

  请看下面的代码：

  ```
  　　var s1 = Op1();
  　　var s2 = Op2();
  　　var s3 = concat(s1, s2);
  ```

​	由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。

​	多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。

- **代码的热升级**

  函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。[Erlang](http://en.wikipedia.org/wiki/Erlang_(programming_language))语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。

### 函数式的缺点

- 不擅长处理可变状态和IO

  处理可变状态和处理IO，要么引入可变变量，要么通过Monad来进行封装（如State Monad和IO Monad）。

  ```
  System.out.println("Please enter your name: ");
  System.in.readLine();

  ```

  在惰性语言中没人能保证第一行会中第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有continuations，monads以及uniqueness typing。这篇文章仅仅介绍了continuations，以后再讨论monads和uniqueness typing。有意思的是呢，coutinuations处理强制代码以特定顺序执行之外还有其他很多出处，这些我们在后面也会提及。

### 

### 从函数式角度看面向对象三大特性

- #### **封装**

  - **可读性差、调试困难**

    面向对象思想将变量封装到类里，然后使用函数对其进行操作，因此大多函数里有成员变量，导致很多函数和成员变量偶合，成员变量的作用域在整个类，有时候还有子类，代码的可读性差；调试时需要根据变量的变化，导致调试难度。

  - **api使用困难**

    由于函数和类成员变量偶合，在调用某个函数之前可能要先调用其它函数，如果顺序不对，就可能导致异常。

- 继承

  - 使变量的作用域扩大，可读性进一步降低
  - 使函数的作用域扩大，导致一些函数覆盖问题

- 多态

  ​